using System;
using System.IO;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using MySpace.Common.IO;

namespace MySpace.Common.Barf
{
	/// <summary>
	/// Encapsulates methods for serializing/deserializing parts of types.
	/// This class should only be referenced by dynamic code generated by the barf framework.
	/// </summary>
	[Obsolete("This class should only be referenced by dynamic code generated by the barf framework")]
	public static class PartFormatter
	{
		public static void WritePart<T>(T part, BarfSerializationArgs args, PartFlags flags)
		{
			if (flags.IsSet(PartFlags.Dynamic))
			{
				if (!typeof(T).IsValueType && part == null)
				{
					args.Writer.WriteVarInt32(-1);
				}
				else
				{
					var type = part.GetType();
					args.Writer.WriteVarInt32(args.TypeTable.Include(type));
					var serializer = BarfSerializers.Get(type, flags & ~PartFlags.Dynamic);
					serializer.SerializeObject(part, args);
				}
			}
			else
			{
				BarfSerializers.Get<T>(flags).Serialize(part, args);
			}
		}

		public static void ReadPart<T>(T instance, BarfDeserializationArgs args, PartFlags flags)
			where T : class
		{
			ReadPart<T>(ref instance, args, flags);
		}

		public static void ReadPart<T>(ref T instance, BarfDeserializationArgs args, PartFlags flags)
		{
			if (flags.IsSet(PartFlags.Dynamic))
			{
				var index = args.Reader.ReadVarInt32();
				if (index < 0)
				{
					instance = default(T);
				}
				else
				{
					var type = args.TypeTable.GetType(index);
					var serializer = BarfSerializers.Get(type, flags & ~PartFlags.Dynamic);
					object obj = instance;
					serializer.InnerDeserializeObject(ref obj, args);
					instance = (T)obj;
				}
			}
			else
			{
				BarfSerializers.Get<T>(flags).InnerDeserialize(ref instance, args);
			}
		}

		public static void FillRandom<T>(T instance, FillArgs args, PartFlags flags, string partName)
			where T : class
		{
			FillRandom<T>(ref instance, args, flags, partName);
		}

		public static void FillRandom<T>(ref T instance, FillArgs args, PartFlags flags, string partName)
		{
			if (flags.IsSet(PartFlags.Dynamic))
			{
				args.RaiseSkippedWarning(partName, "dynamic or polymorphic fields can't be filled");
				instance = default(T);
				return;
			}
			if (args.BeginDeferredFill<T>())
			{
				var tester = BarfSerializers.GetTester<T>(flags);
				tester.Fill(ref instance, args);
				args.EndDeferredFill<T>();
			}
		}

		public static void AssertAreEqual<T>(T expected, T actual, PartFlags flags, AssertArgs args, string partName)
		{
			if (flags.IsSet(PartFlags.Dynamic))
			{
				if (expected == null)
				{
					Assert.AreEqual(null, actual);
					return;
				}
				Assert.AreEqual(expected.GetType(), actual.GetType(), partName);

				var tester = BarfSerializers.GetTester(expected.GetType(), flags & ~PartFlags.Dynamic);
				tester.AssertAreEqual(expected, actual, args);
			}
			else
			{
				var tester = BarfSerializers.GetTester<T>(flags);
				tester.AssertAreEqual(expected, actual, args);
			}
		}

		public static void WriteVersionSerializable<T>(T part, IPrimitiveWriter writer)
			where T : IVersionSerializable
		{
			if (part == null)
			{
				writer.WriteVarInt32(-1);
				return;
			}

			var currentVersion = part.CurrentVersion;

			if (currentVersion < 0)
			{
				throw new InvalidOperationException(string.Format("IVersionSerializable.CurrentVersion of Type=\"{0}\" returned a value of {1} but values are not allowed to be negative.", part.GetType(), currentVersion));
			}

			writer.WriteVarInt32(currentVersion);
			part.Serialize(writer);
		}

		public static T ReadVersionSerializable<T>(IPrimitiveReader reader)
			where T : IVersionSerializable
		{
			var version = reader.ReadVarInt32();
			if (version == -1)
			{
				return default(T);
			}

			if (version < 0)
			{
				throw new InvalidDataException();
			}

			var instance = DynamicMethods.GetCtor<T>()();
			reader.Response = SerializationResponse.Success;
			instance.Deserialize(reader, version);
			if (reader.Response != SerializationResponse.Success)
			{
				throw new UnhandledVersionException(string.Format(
					"IPrimitiveReader.Response set to {0} by IVersionSerializable code in Type=\"{1}\", CurrentVersion=\"{2}\", StreamVersion=\"{3}\"",
					reader.Response, typeof(T).FullName, instance.CurrentVersion, version));
			}
			return instance;
		}

		public static void WriteCustomSerializable<T>(T part, IPrimitiveWriter writer)
			where T : ICustomSerializable
		{
			if (part == null)
			{
				writer.WriteVarInt32(-1);
			}
			else
			{
				writer.WriteVarInt32(0);
				part.Serialize(writer);
			}
		}

		public static T ReadCustomSerializable<T>(IPrimitiveReader reader)
			where T : ICustomSerializable
		{
			int header = reader.ReadVarInt32();
			if (header == -1)
			{
				return default(T);
			}
			if (header != 0)
			{
				throw new UnhandledVersionException(0, header);
			}
			var instance = DynamicMethods.GetCtor<T>()();
			instance.Deserialize(reader);
			return instance;
		}
	}
}
